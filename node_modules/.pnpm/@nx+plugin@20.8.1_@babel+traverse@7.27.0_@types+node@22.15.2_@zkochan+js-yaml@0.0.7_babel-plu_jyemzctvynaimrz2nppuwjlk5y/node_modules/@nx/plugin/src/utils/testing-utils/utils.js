"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fileExists = exports.directoryExists = void 0;
exports.copyNodeModules = copyNodeModules;
exports.expectTestsPass = expectTestsPass;
exports.updateFile = updateFile;
exports.renameFile = renameFile;
exports.checkFilesExist = checkFilesExist;
exports.listFiles = listFiles;
exports.readJson = readJson;
exports.readFile = readFile;
exports.cleanup = cleanup;
exports.rmDist = rmDist;
exports.removeTmpProject = removeTmpProject;
exports.getCwd = getCwd;
exports.exists = exists;
exports.getSize = getSize;
const node_fs_1 = require("node:fs");
const path_1 = require("path");
const paths_1 = require("./paths");
const devkit_1 = require("@nx/devkit");
const fileutils_1 = require("nx/src/utils/fileutils");
Object.defineProperty(exports, "directoryExists", { enumerable: true, get: function () { return fileutils_1.directoryExists; } });
Object.defineProperty(exports, "fileExists", { enumerable: true, get: function () { return fileutils_1.fileExists; } });
/**
 * Copies module folders from the working directory to the e2e directory
 * @param modules a list of module names or scopes to copy
 */
function copyNodeModules(modules) {
    modules.forEach((module) => {
        (0, node_fs_1.rmSync)(`${(0, paths_1.tmpProjPath)()}/node_modules/${module}`, {
            recursive: true,
            force: true,
        });
        (0, node_fs_1.cpSync)(`./node_modules/${module}`, `${(0, paths_1.tmpProjPath)()}/node_modules/${module}`, { recursive: true });
    });
}
/**
 * Assert test output from a asynchronous CLI command.
 *
 * @param output Output from an asynchronous command
 */
function expectTestsPass(output) {
    expect(output.stderr).toContain('Ran all test suites');
    expect(output.stderr).not.toContain('fail');
}
// type callback =
/**
 * Update a file's content in the e2e directory.
 *
 * If the `content` param is a callback, it will provide the original file content as an argument.
 *
 * @param file Path of the file in the e2e directory
 * @param content Content to replace the original content with
 */
function updateFile(file, content) {
    (0, node_fs_1.mkdirSync)((0, path_1.dirname)((0, paths_1.tmpProjPath)(file)), { recursive: true });
    if (typeof content === 'string') {
        (0, node_fs_1.writeFileSync)((0, paths_1.tmpProjPath)(file), content);
    }
    else {
        (0, node_fs_1.writeFileSync)((0, paths_1.tmpProjPath)(file), content((0, node_fs_1.readFileSync)((0, paths_1.tmpProjPath)(file)).toString()));
    }
}
/**
 * Rename a file or directory within the e2e directory.
 * @param path Original path
 * @param newPath New path
 */
function renameFile(path, newPath) {
    (0, node_fs_1.mkdirSync)((0, path_1.dirname)((0, paths_1.tmpProjPath)(newPath)), { recursive: true });
    (0, node_fs_1.renameSync)((0, paths_1.tmpProjPath)(path), (0, paths_1.tmpProjPath)(newPath));
}
/**
 * Check if the file or directory exists.
 *
 * If a path starts with `/` or `C:/`, it will check it as absolute. Otherwise it will check within the e2e directory.
 *
 * @param expectedPaths Files or directories to check
 * @usage `checkFileExists('file1', 'file2', '/var/user/file')`
 */
function checkFilesExist(...expectedPaths) {
    expectedPaths.forEach((path) => {
        const filePath = (0, path_1.isAbsolute)(path) ? path : (0, paths_1.tmpProjPath)(path);
        if (!exists(filePath)) {
            throw new Error(`'${filePath}' does not exist`);
        }
    });
}
/**
 * Get a list of all files within a directory.
 * @param dirName Directory name within the e2e directory.
 */
function listFiles(dirName) {
    return (0, node_fs_1.readdirSync)((0, paths_1.tmpProjPath)(dirName));
}
/**
 * Read a JSON file.
 * @param path Path to the JSON file. Absolute or relative to the e2e directory.
 * @param options JSON parse options
 */
function readJson(path, options) {
    return (0, devkit_1.parseJson)(readFile(path), options);
}
/**
 * Read a file.
 * @param path Path to the file. Absolute or relative to the e2e directory.
 */
function readFile(path) {
    const filePath = (0, path_1.isAbsolute)(path) ? path : (0, paths_1.tmpProjPath)(path);
    return (0, node_fs_1.readFileSync)(filePath, 'utf-8');
}
/**
 * Deletes the e2e directory
 */
function cleanup() {
    (0, node_fs_1.rmSync)((0, paths_1.tmpProjPath)(), { recursive: true, force: true });
}
/**
 * Remove the dist folder from the e2e directory
 */
function rmDist() {
    (0, node_fs_1.rmSync)(`${(0, paths_1.tmpProjPath)()}/dist`, { recursive: true, force: true });
}
function removeTmpProject(project) {
    (0, node_fs_1.rmSync)(`${(0, paths_1.tmpFolder)()}/${project}`, { recursive: true, force: true });
}
/**
 * Get the currend `cwd` in the process
 */
function getCwd() {
    return process.cwd();
}
/**
 * Check if a file or directory exists.
 * @param path Path to file or directory
 */
function exists(path) {
    return (0, fileutils_1.directoryExists)(path) || (0, fileutils_1.fileExists)(path);
}
/**
 * Get the size of a file on disk
 * @param filePath Path to the file
 */
function getSize(filePath) {
    return (0, node_fs_1.statSync)(filePath).size;
}
