"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getArtifactMetadataDirectory = getArtifactMetadataDirectory;
const devkit_1 = require("@nx/devkit");
const posix_1 = require("node:path/posix");
function getArtifactMetadataDirectory(tree, projectName, sourceDirectory, isTsSolutionSetup) {
    const project = (0, devkit_1.readProjectConfiguration)(tree, projectName);
    if (!isTsSolutionSetup) {
        return `./${(0, posix_1.relative)(project.root, sourceDirectory)}`;
    }
    const target = Object.values(project.targets ?? {}).find((t) => t.executor === '@nx/js:tsc' || t.executor === '@nx/js:swc');
    // the repo is using the new ts setup where the outputs are contained inside the project
    if (target?.executor === '@nx/js:tsc') {
        // the @nx/js:tsc executor defaults rootDir to the project root
        return `./${(0, posix_1.join)('dist', (0, posix_1.relative)(target.options.rootDir ?? project.root, sourceDirectory))}`;
    }
    if (target?.executor === '@nx/js:swc') {
        return `./${(0, posix_1.join)('dist', target.options.stripLeadingPaths
            ? (0, posix_1.relative)((0, posix_1.dirname)(target.options.main), sourceDirectory)
            : (0, posix_1.relative)(project.root, sourceDirectory))}`;
    }
    // We generate the plugin with the executors above, so we shouldn't get here
    // unless the user manually changed the build process. In that case, we can't
    // reliably determine the output directory because it depends on the build
    // tool, so we'll just assume some defaults.
    const baseDir = project.sourceRoot ??
        (tree.exists((0, posix_1.join)(project.root, 'src'))
            ? (0, posix_1.join)(project.root, 'src')
            : project.root);
    return `./${(0, posix_1.join)('dist', (0, posix_1.relative)(baseDir, sourceDirectory))}`;
}
