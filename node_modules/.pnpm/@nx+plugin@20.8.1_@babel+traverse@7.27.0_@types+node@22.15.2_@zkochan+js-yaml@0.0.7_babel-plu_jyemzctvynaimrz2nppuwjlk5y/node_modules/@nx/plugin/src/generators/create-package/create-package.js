"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPackageGenerator = createPackageGenerator;
exports.createPackageGeneratorInternal = createPackageGeneratorInternal;
const devkit_1 = require("@nx/devkit");
const js_1 = require("@nx/js");
const add_tslib_dependencies_1 = require("@nx/js/src/utils/typescript/add-tslib-dependencies");
const ts_solution_setup_1 = require("@nx/js/src/utils/typescript/ts-solution-setup");
const versions_1 = require("@nx/js/src/utils/versions");
const versions_2 = require("nx/src/utils/versions");
const path_1 = require("path");
const has_generator_1 = require("../../utils/has-generator");
const generator_1 = require("../generator/generator");
const normalize_schema_1 = require("./utils/normalize-schema");
async function createPackageGenerator(host, schema) {
    return await createPackageGeneratorInternal(host, {
        useProjectJson: true,
        addPlugin: false,
        ...schema,
    });
}
async function createPackageGeneratorInternal(host, schema) {
    const tasks = [];
    const options = await (0, normalize_schema_1.normalizeSchema)(host, schema);
    const pluginPackageName = await addPresetGenerator(host, options);
    if (options.bundler === 'tsc') {
        tasks.push((0, add_tslib_dependencies_1.addTsLibDependencies)(host));
    }
    const installTask = (0, devkit_1.addDependenciesToPackageJson)(host, {
        'create-nx-workspace': versions_2.nxVersion,
    }, {});
    tasks.push(installTask);
    const cliPackageTask = await createCliPackage(host, options, pluginPackageName);
    tasks.push(cliPackageTask);
    if (options.e2eProject) {
        addE2eProject(host, options);
    }
    if (!options.skipFormat) {
        await (0, devkit_1.formatFiles)(host);
    }
    return (0, devkit_1.runTasksInSerial)(...tasks);
}
/**
 * Add a preset generator to the plugin if it doesn't exist
 * @param host
 * @param schema
 * @returns package name of the plugin
 */
async function addPresetGenerator(host, schema) {
    const { root: projectRoot } = (0, devkit_1.readProjectConfiguration)(host, schema.project);
    if (!(0, has_generator_1.hasGenerator)(host, schema.project, 'preset')) {
        await (0, generator_1.generatorGenerator)(host, {
            name: 'preset',
            path: (0, path_1.join)(projectRoot, 'src/generators/preset/generator'),
            unitTestRunner: schema.unitTestRunner,
            skipFormat: true,
            skipLintChecks: schema.linter === 'none',
        });
    }
    return (0, devkit_1.readJson)(host, (0, devkit_1.joinPathFragments)(projectRoot, 'package.json'))?.name;
}
async function createCliPackage(host, options, pluginPackageName) {
    const jsLibraryTask = await (0, js_1.libraryGenerator)(host, {
        ...options,
        directory: options.directory,
        rootProject: false,
        config: 'project',
        publishable: true,
        bundler: options.bundler,
        importPath: options.name,
        skipFormat: true,
        skipTsConfig: true,
        useTscExecutor: true,
    });
    host.delete((0, devkit_1.joinPathFragments)(options.projectRoot, 'src'));
    const isTsSolutionSetup = (0, ts_solution_setup_1.isUsingTsSolutionSetup)(host);
    // Add the bin entry to the package.json
    (0, devkit_1.updateJson)(host, (0, devkit_1.joinPathFragments)(options.projectRoot, 'package.json'), (packageJson) => {
        packageJson.bin = {
            [options.name]: './bin/index.js',
        };
        if (isTsSolutionSetup) {
            packageJson.bin[options.name] = './dist/bin/index.js';
            // this package only exposes a binary entry point and no JS programmatic API
            delete packageJson.main;
            delete packageJson.types;
            delete packageJson.typings;
            delete packageJson.exports;
        }
        packageJson.dependencies = {
            'create-nx-workspace': versions_2.nxVersion,
            ...(options.bundler === 'tsc' && { tslib: versions_1.tsLibVersion }),
        };
        return packageJson;
    });
    // update project build target to use the bin entry
    const projectConfiguration = (0, devkit_1.readProjectConfiguration)(host, options.projectName);
    projectConfiguration.sourceRoot = (0, devkit_1.joinPathFragments)(options.projectRoot, 'bin');
    projectConfiguration.targets.build.options.main = (0, devkit_1.joinPathFragments)(options.projectRoot, 'bin/index.ts');
    projectConfiguration.implicitDependencies = [options.project];
    if (options.isTsSolutionSetup) {
        if (options.bundler === 'tsc') {
            projectConfiguration.targets.build.options.generatePackageJson = false;
        }
        else if (options.bundler === 'swc') {
            delete projectConfiguration.targets.build.options.stripLeadingPaths;
        }
    }
    (0, devkit_1.updateProjectConfiguration)(host, options.projectName, projectConfiguration);
    // Add bin files and update rootDir in tsconfg.lib.json
    (0, devkit_1.updateJson)(host, (0, devkit_1.joinPathFragments)(options.projectRoot, 'tsconfig.lib.json'), (tsConfig) => {
        tsConfig.include.push('bin/**/*.ts');
        tsConfig.compilerOptions ??= {};
        tsConfig.compilerOptions.rootDir = '.';
        return tsConfig;
    });
    (0, devkit_1.generateFiles)(host, (0, devkit_1.joinPathFragments)(__dirname, './files/create-framework-package'), options.projectRoot, {
        ...options,
        preset: pluginPackageName,
        tmpl: '',
    });
    return jsLibraryTask;
}
/**
 * Add a test file to plugin e2e project
 * @param host
 * @param options
 * @returns
 */
function addE2eProject(host, options) {
    const e2eProjectConfiguration = (0, devkit_1.readProjectConfiguration)(host, options.e2eProject);
    const projectConfiguration = (0, devkit_1.readProjectConfiguration)(host, options.project);
    const { name: pluginPackageName } = (0, devkit_1.readJson)(host, (0, path_1.join)(projectConfiguration.root, 'package.json'));
    (0, devkit_1.generateFiles)(host, (0, devkit_1.joinPathFragments)(__dirname, './files/e2e'), e2eProjectConfiguration.sourceRoot, {
        pluginName: options.project,
        cliName: options.name,
        packageManagerCommands: (0, devkit_1.getPackageManagerCommand)(),
        pluginPackageName,
        tmpl: '',
    });
}
exports.default = createPackageGenerator;
