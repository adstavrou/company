"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.e2eProjectGenerator = e2eProjectGenerator;
exports.e2eProjectGeneratorInternal = e2eProjectGeneratorInternal;
const devkit_1 = require("@nx/devkit");
const project_name_and_root_utils_1 = require("@nx/devkit/src/generators/project-name-and-root-utils");
const eslint_1 = require("@nx/eslint");
const jest_1 = require("@nx/jest");
const js_1 = require("@nx/js");
const generator_1 = require("@nx/js/src/generators/setup-verdaccio/generator");
const add_local_registry_scripts_1 = require("@nx/js/src/utils/add-local-registry-scripts");
const generator_prompts_1 = require("@nx/js/src/utils/generator-prompts");
const ts_solution_setup_1 = require("@nx/js/src/utils/typescript/ts-solution-setup");
const path_1 = require("path");
async function normalizeOptions(host, options) {
    const linter = await (0, generator_prompts_1.normalizeLinterOption)(host, options.linter);
    const projectName = options.rootProject ? 'e2e' : `${options.pluginName}-e2e`;
    const nxJson = (0, devkit_1.readNxJson)(host);
    const addPlugin = options.addPlugin ??
        (process.env.NX_ADD_PLUGINS !== 'false' &&
            nxJson.useInferencePlugins !== false);
    let projectRoot;
    const projectNameAndRootOptions = await (0, project_name_and_root_utils_1.determineProjectNameAndRootOptions)(host, {
        name: projectName,
        projectType: 'application',
        directory: options.rootProject || !options.projectDirectory
            ? projectName
            : `${options.projectDirectory}-e2e`,
    });
    projectRoot = projectNameAndRootOptions.projectRoot;
    const pluginPropertyName = (0, devkit_1.names)(options.pluginName).propertyName;
    const isTsSolutionSetup = (0, ts_solution_setup_1.isUsingTsSolutionSetup)(host);
    return {
        ...options,
        projectName,
        linter,
        pluginPropertyName,
        projectRoot,
        addPlugin,
        useProjectJson: options.useProjectJson ?? !isTsSolutionSetup,
        isTsSolutionSetup,
    };
}
function validatePlugin(host, pluginName) {
    try {
        (0, devkit_1.readProjectConfiguration)(host, pluginName);
    }
    catch {
        throw new Error(`Project name "${pluginName}" doesn't not exist.`);
    }
}
function addFiles(host, options) {
    const projectConfiguration = (0, devkit_1.readProjectConfiguration)(host, options.pluginName);
    const { name: pluginPackageName } = (0, devkit_1.readJson)(host, (0, path_1.join)(projectConfiguration.root, 'package.json'));
    const simplePluginName = options.pluginName.split('/').pop();
    (0, devkit_1.generateFiles)(host, (0, path_1.join)(__dirname, './files'), options.projectRoot, {
        ...options,
        tmpl: '',
        rootTsConfigPath: (0, js_1.getRelativePathToRootTsConfig)(host, options.projectRoot),
        packageManagerCommands: (0, devkit_1.getPackageManagerCommand)(),
        pluginPackageName,
        simplePluginName,
    });
}
async function addJest(host, options) {
    const projectConfiguration = {
        name: options.projectName,
        root: options.projectRoot,
        projectType: 'application',
        sourceRoot: `${options.projectRoot}/src`,
        implicitDependencies: [options.pluginName],
    };
    if (options.isTsSolutionSetup) {
        (0, devkit_1.writeJson)(host, (0, devkit_1.joinPathFragments)(options.projectRoot, 'package.json'), {
            name: options.projectName,
            version: '0.0.1',
            private: true,
        });
        (0, devkit_1.updateProjectConfiguration)(host, options.projectName, projectConfiguration);
    }
    else {
        projectConfiguration.targets = {};
        (0, devkit_1.addProjectConfiguration)(host, options.projectName, projectConfiguration);
    }
    const jestTask = await (0, jest_1.configurationGenerator)(host, {
        project: options.projectName,
        targetName: 'e2e',
        setupFile: 'none',
        supportTsx: false,
        skipSerializers: true,
        skipFormat: true,
        addPlugin: options.addPlugin,
        compiler: options.isTsSolutionSetup ? 'swc' : undefined,
    });
    const { startLocalRegistryPath, stopLocalRegistryPath } = (0, add_local_registry_scripts_1.addLocalRegistryScripts)(host);
    (0, jest_1.addPropertyToJestConfig)(host, (0, path_1.join)(options.projectRoot, 'jest.config.ts'), 'globalSetup', (0, path_1.join)((0, devkit_1.offsetFromRoot)(options.projectRoot), startLocalRegistryPath));
    (0, jest_1.addPropertyToJestConfig)(host, (0, path_1.join)(options.projectRoot, 'jest.config.ts'), 'globalTeardown', (0, path_1.join)((0, devkit_1.offsetFromRoot)(options.projectRoot), stopLocalRegistryPath));
    const project = (0, devkit_1.readProjectConfiguration)(host, options.projectName);
    project.targets ??= {};
    const e2eTarget = project.targets.e2e;
    project.targets.e2e = {
        ...e2eTarget,
        dependsOn: [`^build`],
        options: {
            ...e2eTarget.options,
            runInBand: true,
        },
    };
    (0, devkit_1.updateProjectConfiguration)(host, options.projectName, project);
    return jestTask;
}
async function addLintingToApplication(tree, options) {
    const lintTask = await (0, eslint_1.lintProjectGenerator)(tree, {
        linter: options.linter,
        project: options.projectName,
        tsConfigPaths: [
            (0, devkit_1.joinPathFragments)(options.projectRoot, 'tsconfig.app.json'),
        ],
        unitTestRunner: 'jest',
        skipFormat: true,
        setParserOptionsProject: false,
        addPlugin: options.addPlugin,
    });
    return lintTask;
}
function updatePluginPackageJson(tree, options) {
    const { root } = (0, devkit_1.readProjectConfiguration)(tree, options.pluginName);
    (0, devkit_1.updateJson)(tree, (0, devkit_1.joinPathFragments)(root, 'package.json'), (json) => {
        // to publish the plugin, we need to remove the private flag
        delete json.private;
        return json;
    });
}
async function e2eProjectGenerator(host, schema) {
    return await e2eProjectGeneratorInternal(host, {
        addPlugin: false,
        useProjectJson: true,
        ...schema,
    });
}
async function e2eProjectGeneratorInternal(host, schema) {
    const tasks = [];
    validatePlugin(host, schema.pluginName);
    const options = await normalizeOptions(host, schema);
    addFiles(host, options);
    tasks.push(await (0, generator_1.setupVerdaccio)(host, {
        skipFormat: true,
    }));
    tasks.push(await addJest(host, options));
    updatePluginPackageJson(host, options);
    if (options.linter !== 'none') {
        tasks.push(await addLintingToApplication(host, {
            ...options,
        }));
    }
    if (options.isTsSolutionSetup && !options.rootProject) {
        // update root  tsconfig.json references with the new lib tsconfig
        (0, devkit_1.updateJson)(host, 'tsconfig.json', (json) => {
            json.references ??= [];
            json.references.push({
                path: options.projectRoot.startsWith('./')
                    ? options.projectRoot
                    : './' + options.projectRoot,
            });
            return json;
        });
    }
    // If we are using the new TS solution
    // We need to update the workspace file (package.json or pnpm-workspaces.yaml) to include the new project
    if (options.isTsSolutionSetup) {
        await (0, ts_solution_setup_1.addProjectToTsSolutionWorkspace)(host, options.projectRoot);
    }
    if (!options.skipFormat) {
        await (0, devkit_1.formatFiles)(host);
    }
    return (0, devkit_1.runTasksInSerial)(...tasks);
}
exports.default = e2eProjectGenerator;
