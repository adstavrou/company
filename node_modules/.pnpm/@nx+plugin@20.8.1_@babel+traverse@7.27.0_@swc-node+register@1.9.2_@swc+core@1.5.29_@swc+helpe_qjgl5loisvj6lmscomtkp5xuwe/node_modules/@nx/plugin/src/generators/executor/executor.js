"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createExecutorsJson = createExecutorsJson;
exports.executorGenerator = executorGenerator;
const devkit_1 = require("@nx/devkit");
const artifact_name_and_directory_utils_1 = require("@nx/devkit/src/generators/artifact-name-and-directory-utils");
const ts_solution_setup_1 = require("@nx/js/src/utils/typescript/ts-solution-setup");
const path_1 = require("path");
const paths_1 = require("../../utils/paths");
const versions_1 = require("../../utils/versions");
const generator_1 = require("../lint-checks/generator");
function addFiles(host, options) {
    (0, devkit_1.generateFiles)(host, (0, path_1.join)(__dirname, './files/executor'), options.directory, {
        ...options,
    });
    if (options.unitTestRunner === 'none') {
        host.delete((0, devkit_1.joinPathFragments)(options.directory, `${options.fileName}.spec.ts`));
    }
}
function addHasherFiles(host, options) {
    (0, devkit_1.generateFiles)(host, (0, path_1.join)(__dirname, './files/hasher'), options.directory, {
        ...options,
    });
    if (options.unitTestRunner === 'none') {
        host.delete((0, devkit_1.joinPathFragments)(options.directory, 'hasher.spec.ts'));
    }
}
async function createExecutorsJson(host, projectRoot, projectName, skipLintChecks) {
    (0, devkit_1.updateJson)(host, (0, devkit_1.joinPathFragments)(projectRoot, 'package.json'), (json) => {
        json.executors ??= './executors.json';
        return json;
    });
    (0, devkit_1.writeJson)(host, (0, devkit_1.joinPathFragments)(projectRoot, 'executors.json'), {
        executors: {},
    });
    if (!skipLintChecks) {
        await (0, generator_1.default)(host, {
            projectName,
        });
    }
}
async function updateExecutorJson(host, options) {
    const packageJson = (0, devkit_1.readJson)(host, (0, devkit_1.joinPathFragments)(options.projectRoot, 'package.json'));
    const packageJsonExecutors = packageJson.executors ?? packageJson.builders;
    let executorsPath = packageJsonExecutors
        ? (0, devkit_1.joinPathFragments)(options.projectRoot, packageJsonExecutors)
        : null;
    if (!executorsPath) {
        executorsPath = (0, devkit_1.joinPathFragments)(options.projectRoot, 'executors.json');
    }
    if (!host.exists(executorsPath)) {
        await createExecutorsJson(host, options.projectRoot, options.project, options.skipLintChecks);
        if (options.isTsSolutionSetup) {
            (0, devkit_1.updateJson)(host, (0, devkit_1.joinPathFragments)(options.projectRoot, 'package.json'), (json) => {
                const filesSet = new Set(json.files ?? ['dist', '!**/*.tsbuildinfo']);
                filesSet.add('executors.json');
                json.files = [...filesSet];
                return json;
            });
        }
    }
    // add dependencies
    (0, devkit_1.updateJson)(host, (0, devkit_1.joinPathFragments)(options.projectRoot, 'package.json'), (json) => {
        json.dependencies = {
            '@nx/devkit': versions_1.nxVersion,
            ...json.dependencies,
        };
        return json;
    });
    return (0, devkit_1.updateJson)(host, executorsPath, (json) => {
        let executors = json.executors ?? json.builders;
        executors ||= {};
        const dir = (0, paths_1.getArtifactMetadataDirectory)(host, options.project, options.directory, options.isTsSolutionSetup);
        executors[options.name] = {
            implementation: `${dir}/${options.fileName}`,
            schema: `${dir}/schema.json`,
            description: options.description,
        };
        if (options.includeHasher) {
            executors[options.name].hasher = `${dir}/hasher`;
        }
        json.executors = executors;
        return json;
    });
}
async function normalizeOptions(tree, options) {
    const { artifactName: name, directory, fileName, project, } = await (0, artifact_name_and_directory_utils_1.determineArtifactNameAndDirectoryOptions)(tree, {
        path: options.path,
        name: options.name,
        allowedFileExtensions: ['ts'],
        fileExtension: 'ts',
    });
    const { className, propertyName } = (0, devkit_1.names)(name);
    const { root: projectRoot, sourceRoot: projectSourceRoot } = (0, devkit_1.readProjectConfiguration)(tree, project);
    let description;
    if (options.description) {
        description = options.description;
    }
    else {
        description = `${name} executor`;
    }
    return {
        ...options,
        fileName,
        project,
        directory,
        name,
        className,
        propertyName,
        description,
        projectRoot,
        projectSourceRoot: projectSourceRoot ?? (0, path_1.join)(projectRoot, 'src'),
        isTsSolutionSetup: (0, ts_solution_setup_1.isUsingTsSolutionSetup)(tree),
    };
}
async function executorGenerator(host, schema) {
    const options = await normalizeOptions(host, schema);
    addFiles(host, options);
    if (options.includeHasher) {
        addHasherFiles(host, options);
    }
    await updateExecutorJson(host, options);
    if (!schema.skipFormat) {
        await (0, devkit_1.formatFiles)(host);
    }
}
exports.default = executorGenerator;
