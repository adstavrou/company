"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createGeneratorsJson = createGeneratorsJson;
exports.generatorGenerator = generatorGenerator;
const devkit_1 = require("@nx/devkit");
const artifact_name_and_directory_utils_1 = require("@nx/devkit/src/generators/artifact-name-and-directory-utils");
const ts_solution_setup_1 = require("@nx/js/src/utils/typescript/ts-solution-setup");
const node_path_1 = require("node:path");
const has_generator_1 = require("../../utils/has-generator");
const paths_1 = require("../../utils/paths");
const versions_1 = require("../../utils/versions");
const generator_1 = require("../lint-checks/generator");
async function normalizeOptions(tree, options) {
    const { artifactName: name, directory, fileName, project, } = await (0, artifact_name_and_directory_utils_1.determineArtifactNameAndDirectoryOptions)(tree, {
        path: options.path,
        name: options.name,
        allowedFileExtensions: ['ts'],
        fileExtension: 'ts',
    });
    const { className, propertyName } = (0, devkit_1.names)(name);
    const { root: projectRoot, sourceRoot: projectSourceRoot } = (0, devkit_1.readProjectConfiguration)(tree, project);
    let description;
    if (options.description) {
        description = options.description;
    }
    else {
        description = `${name} generator`;
    }
    return {
        ...options,
        directory,
        project,
        name,
        fileName,
        className,
        propertyName,
        description,
        projectRoot,
        projectSourceRoot: projectSourceRoot ?? (0, node_path_1.join)(projectRoot, 'src'),
        isTsSolutionSetup: (0, ts_solution_setup_1.isUsingTsSolutionSetup)(tree),
    };
}
function addFiles(host, options) {
    const indexPath = (0, node_path_1.join)(options.directory, 'files/src/index.ts.template');
    if (!host.exists(indexPath)) {
        host.write(indexPath, 'const variable = "<%= name %>";');
    }
    (0, devkit_1.generateFiles)(host, (0, node_path_1.join)(__dirname, './files/generator'), options.directory, {
        ...options,
        generatorFnName: `${options.propertyName}Generator`,
        schemaInterfaceName: `${options.className}GeneratorSchema`,
    });
    if (options.unitTestRunner === 'none') {
        host.delete((0, node_path_1.join)(options.directory, `${options.fileName}.spec.ts`));
    }
}
async function createGeneratorsJson(host, projectRoot, projectName, skipLintChecks, skipFormat) {
    (0, devkit_1.updateJson)(host, (0, devkit_1.joinPathFragments)(projectRoot, 'package.json'), (json) => {
        json.generators ??= './generators.json';
        return json;
    });
    (0, devkit_1.writeJson)(host, (0, devkit_1.joinPathFragments)(projectRoot, 'generators.json'), {
        generators: {},
    });
    if (!skipLintChecks) {
        await (0, generator_1.default)(host, {
            projectName,
            skipFormat,
        });
    }
}
async function updateGeneratorJson(host, options) {
    const packageJson = (0, devkit_1.readJson)(host, (0, devkit_1.joinPathFragments)(options.projectRoot, 'package.json'));
    const packageJsonGenerators = packageJson.generators ?? packageJson.schematics;
    let generatorsPath = packageJsonGenerators
        ? (0, devkit_1.joinPathFragments)(options.projectRoot, packageJsonGenerators)
        : null;
    if (!generatorsPath) {
        generatorsPath = (0, devkit_1.joinPathFragments)(options.projectRoot, 'generators.json');
    }
    if (!host.exists(generatorsPath)) {
        await createGeneratorsJson(host, options.projectRoot, options.project, options.skipLintChecks, options.skipFormat);
        if (options.isTsSolutionSetup) {
            (0, devkit_1.updateJson)(host, (0, devkit_1.joinPathFragments)(options.projectRoot, 'package.json'), (json) => {
                const filesSet = new Set(json.files ?? ['dist', '!**/*.tsbuildinfo']);
                filesSet.add('generators.json');
                json.files = [...filesSet];
                return json;
            });
        }
    }
    // add dependencies
    (0, devkit_1.updateJson)(host, (0, devkit_1.joinPathFragments)(options.projectRoot, 'package.json'), (json) => {
        json.dependencies = {
            '@nx/devkit': versions_1.nxVersion,
            ...json.dependencies,
        };
        return json;
    });
    (0, devkit_1.updateJson)(host, generatorsPath, (json) => {
        let generators = json.generators ?? json.schematics;
        generators = generators || {};
        const dir = (0, paths_1.getArtifactMetadataDirectory)(host, options.project, options.directory, options.isTsSolutionSetup);
        generators[options.name] = {
            factory: `${dir}/${options.fileName}`,
            schema: `${dir}/schema.json`,
            description: options.description,
        };
        // @todo(v17): Remove this, prop is defunct.
        if (options.name === 'preset') {
            generators[options.name]['x-use-standalone-layout'] = true;
        }
        json.generators = generators;
        return json;
    });
}
async function generatorGenerator(host, schema) {
    const options = await normalizeOptions(host, schema);
    if ((0, has_generator_1.hasGenerator)(host, options.project, options.name)) {
        throw new Error(`Generator ${options.name} already exists.`);
    }
    addFiles(host, options);
    await updateGeneratorJson(host, options);
    if (!options.skipFormat) {
        await (0, devkit_1.formatFiles)(host);
    }
}
exports.default = generatorGenerator;
