"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pluginGenerator = pluginGenerator;
exports.pluginGeneratorInternal = pluginGeneratorInternal;
const devkit_1 = require("@nx/devkit");
const eslint_1 = require("@nx/eslint");
const js_1 = require("@nx/js");
const add_swc_dependencies_1 = require("@nx/js/src/utils/swc/add-swc-dependencies");
const add_tslib_dependencies_1 = require("@nx/js/src/utils/typescript/add-tslib-dependencies");
const path = require("path");
const e2e_1 = require("../e2e-project/e2e");
const generator_1 = require("../lint-checks/generator");
const normalize_schema_1 = require("./utils/normalize-schema");
const nxVersion = require('../../../package.json').version;
async function addFiles(host, options) {
    host.delete((0, devkit_1.normalizePath)(`${options.projectRoot}/src/lib`));
    (0, devkit_1.generateFiles)(host, path.join(__dirname, './files/plugin'), options.projectRoot, {
        ...options,
        tmpl: '',
    });
}
function updatePluginConfig(host, options) {
    const project = (0, devkit_1.readProjectConfiguration)(host, options.projectName);
    if (project.targets.build) {
        if (options.isTsSolutionSetup && options.bundler === 'tsc') {
            project.targets.build.options.rootDir =
                project.sourceRoot ?? (0, devkit_1.joinPathFragments)(project.root, 'src');
            project.targets.build.options.generatePackageJson = false;
        }
        project.targets.build.options.assets = [
            ...(project.targets.build.options.assets ?? []),
        ];
        const root = options.projectRoot === '.' ? '.' : './' + options.projectRoot;
        if (options.isTsSolutionSetup) {
            project.targets.build.options.assets.push({ input: `${root}/src`, glob: '**/!(*.ts)', output: '.' }, { input: `${root}/src`, glob: '**/*.d.ts', output: '.' });
        }
        else {
            project.targets.build.options.assets.push({ input: `${root}/src`, glob: '**/!(*.ts)', output: './src' }, { input: `${root}/src`, glob: '**/*.d.ts', output: './src' }, { input: root, glob: 'generators.json', output: '.' }, { input: root, glob: 'executors.json', output: '.' });
        }
        (0, devkit_1.updateProjectConfiguration)(host, options.projectName, project);
    }
}
async function pluginGenerator(tree, schema) {
    return await pluginGeneratorInternal(tree, {
        useProjectJson: true,
        addPlugin: false,
        ...schema,
    });
}
async function pluginGeneratorInternal(host, schema) {
    const options = await (0, normalize_schema_1.normalizeOptions)(host, schema);
    const tasks = [];
    tasks.push(await (0, js_1.libraryGenerator)(host, {
        ...schema,
        name: options.name,
        directory: options.projectRoot,
        config: 'project',
        bundler: options.bundler,
        publishable: options.publishable,
        importPath: options.importPath,
        linter: options.linter,
        unitTestRunner: options.unitTestRunner,
        useProjectJson: options.useProjectJson,
        addPlugin: options.addPlugin,
        skipFormat: true,
        useTscExecutor: true,
    }));
    if (options.isTsSolutionSetup) {
        (0, devkit_1.updateJson)(host, (0, devkit_1.joinPathFragments)(options.projectRoot, 'package.json'), (json) => {
            delete json.type;
            return json;
        });
    }
    if (options.bundler === 'tsc') {
        tasks.push((0, add_tslib_dependencies_1.addTsLibDependencies)(host));
    }
    tasks.push((0, devkit_1.addDependenciesToPackageJson)(host, {
        '@nx/devkit': nxVersion,
    }, {
        [options.unitTestRunner === 'vitest' ? '@nx/vite' : '@nx/jest']: nxVersion,
        '@nx/js': nxVersion,
        '@nx/plugin': nxVersion,
    }));
    // Ensures Swc Deps are installed to handle running
    // local plugin generators and executors
    tasks.push((0, add_swc_dependencies_1.addSwcDependencies)(host));
    tasks.push((0, add_swc_dependencies_1.addSwcRegisterDependencies)(host));
    await addFiles(host, options);
    updatePluginConfig(host, options);
    if (options.e2eTestRunner !== 'none') {
        tasks.push(await (0, e2e_1.e2eProjectGenerator)(host, {
            pluginName: options.projectName,
            projectDirectory: options.projectDirectory,
            pluginOutputPath: (0, devkit_1.joinPathFragments)('dist', options.rootProject ? options.projectName : options.projectRoot),
            npmPackageName: options.importPath,
            skipFormat: true,
            rootProject: options.rootProject,
            linter: options.linter,
            useProjectJson: options.useProjectJson,
            addPlugin: options.addPlugin,
        }));
    }
    if (options.linter === eslint_1.Linter.EsLint && !options.skipLintChecks) {
        await (0, generator_1.default)(host, { projectName: options.projectName });
    }
    if (!options.skipFormat) {
        await (0, devkit_1.formatFiles)(host);
    }
    return (0, devkit_1.runTasksInSerial)(...tasks);
}
exports.default = pluginGenerator;
