import { Tree, formatFiles } from '@nx/devkit';
import { CustomLibGeneratorSchema } from './schema';
import { prompt } from 'enquirer';

export default async function (tree: Tree, options: CustomLibGeneratorSchema) {
  if (!options.name || options.name.trim() === '') {
    let response = await prompt<{ libName: string }>([
      {
        type: 'input',
        name: 'libName',
        message: 'üê∏ How should we name your library?',
        validate: (value) => (value.trim() ? true : 'üëâ You must provide a name!'),
      },
    ]);
    options.name = response.libName;
  }

  if (options.build === undefined) {
    let response = await prompt<{ build: boolean }>([
      {
        type: 'confirm',
        name: 'build',
        message: 'üê∏ Add build target?',
      },
    ]);
    options.build = response.build;
  }

  if (options.unitTest === undefined) {
    const response = await prompt<{ unitTest: boolean }>([
      {
        type: 'confirm',
        name: 'unitTest',
        message: 'üê∏ Add unit testing setup?',
      },
    ]);
    options.unitTest = response.unitTest;
  }

  if (!options.files || options.files.length === 0) {
    const response = await prompt<{ files: string[] }>([
      {
        type: 'multiselect',
        name: 'files',
        message: 'üê∏ Select additional files to create:',
        choices: [
          { name: 'utils', message: 'utils.ts' },
          { name: 'constants', message: 'constants.ts' },
          { name: 'types', message: 'types.ts' },
        ],
      },
    ]);
    options.files = response.files as ('utils' | 'constants' | 'types')[];
  }

  let libName = sanitizeLibName(options.name);
  let libRoot = `libs/${libName}`;

  tree.write(
    `${libRoot}/src/index.ts`,
    `export const hello = () => console.log('Hello from ${libName}!');`,
  );
  tree.write(
    `${libRoot}/README.md`,
    `# ${libName}\n\nGenerated by \`company-generators:custom-lib\`.`,
  );
  tree.write(
    `${libRoot}/src/utils.ts`,
    "// Add your utility functions here\n\nexport function exampleUtil() {\n  return 'Hello from utils!';\n}",
  );
  if (options.files?.includes('utils')) {
    tree.write(
      `${libRoot}/src/utils.ts`,
      "// Utility functions\n\nexport function exampleUtil() {\n  return 'Hello from utils';\n}",
    );
  }

  if (options.files?.includes('constants')) {
    tree.write(
      `${libRoot}/src/constants.ts`,
      `// Constants for ${libName}\n\nexport const EXAMPLE_CONSTANT = 'value';`,
    );
  }

  if (options.files?.includes('types')) {
    tree.write(
      `${libRoot}/src/types.ts`,
      `// Type definitions for ${libName}\n\nexport interface ExampleType {\n  id: string;\n}`,
    );
  }

  let projectJson: any = {
    name: libName,
    $schema: '../../node_modules/nx/schemas/project-schema.json',
    sourceRoot: `${libRoot}/src`,
    projectType: 'library',
    targets: {},
    tags: [],
  };

  if (options.build) {
    projectJson.targets.build = {
      executor: 'nx:run-commands',
      options: {
        command: "echo 'Building ${libName}...'",
      },
    };
  }

  if (options.unitTest) {
    projectJson.targets.test = {
      executor: 'nx:run-commands',
      options: {
        command: "echo 'Running tests for ${libName}...'",
      },
    };
  }

  tree.write(`${libRoot}/project.json`, JSON.stringify(projectJson, null, 2));

  await formatFiles(tree);
}

function sanitizeLibName(name: string): string {
  return name
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9-]/g, '-')
    .replace(/--+/g, '-')
    .replace(/^-+|-+$/g, '');
}
